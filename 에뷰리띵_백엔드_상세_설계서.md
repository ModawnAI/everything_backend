# 에뷰리띵 Node.js 백엔드 서버 상세 설계서

## 📱 개요
본 문서는 에뷰리띵 하이브리드 앱(React/Next.js + Shadcn/UI)과 웹 관리자 시스템을 지원하는 Node.js 백엔드 서버의 모든 API 엔드포인트, 미들웨어, 비즈니스 로직에 대한 상세한 기능 정의와 Supabase 데이터베이스와의 상호작용을 설명합니다.

**문서 버전**: 3.2  
**업데이트 날짜**: 2025년 7월 14일  
**주요 변경 사항**:
- v3.2: 피드(소셜) 기능 추가, 인플루언서 자격 조건 구체화, 샵 다이렉트 메시지 기능, 포인트 정책 변경
- v3.1: 예약 '요청' 상태 및 '샵 확정' 필요성 명시
- 앱 플랫폼: Flutter → React/Next.js 하이브리드 앱으로 변경

---

## 🏗️ 아키텍처 개요

### **기술 스택 및 프레임워크**
- **런타임**: Node.js 18+ LTS (최신 안정 버전)
- **프레임워크**: Express.js 4.18+ (RESTful API 구축)
- **언어**: TypeScript 5.0+ (타입 안전성 보장)
- **데이터베이스**: Supabase PostgreSQL (PostGIS 확장 포함)
- **인증**: Supabase Auth + JWT 토큰 검증
- **결제**: 토스페이먼츠 API 연동
- **푸시알림**: Firebase Cloud Messaging (FCM)
- **파일 스토리지**: Supabase Storage
- **로깅**: Winston + Morgan (구조화된 로그)
- **문서화**: Swagger/OpenAPI 3.0
- **환경관리**: dotenv + config 패턴

### **서버 구조 및 디렉토리**
```
src/
├── controllers/          # API 컨트롤러 (요청/응답 처리)
├── services/            # 비즈니스 로직 서비스
├── repositories/        # 데이터 접근 계층
├── middleware/          # 미들웨어 (인증, 검증, 로깅)
├── routes/             # API 라우트 정의
├── types/              # TypeScript 타입 정의
├── utils/              # 유틸리티 함수들
├── config/             # 설정 파일들
├── validators/         # 요청 데이터 검증
├── constants/          # 상수 정의
└── app.ts             # Express 앱 진입점
```

### **데이터 플로우 아키텍처**
```
React/Next.js Hybrid App / Web Admin
         ↓
    Express Router
         ↓
   Authentication Middleware
         ↓
   Request Validation
         ↓
    Controller Layer
         ↓
    Service Layer (비즈니스 로직)
         ↓
   Repository Layer
         ↓
    Supabase Client
         ↓
   PostgreSQL Database
```

---

## 🔐 인증 및 보안 시스템

### **인증 미들웨어 구현**

#### **JWT 토큰 검증 미들웨어**
```typescript
// middleware/auth.middleware.ts
```

#### **기능 및 로직**
1. **토큰 추출 및 검증**
   - Authorization 헤더에서 Bearer 토큰 추출
   - Supabase JWT 시크릿으로 토큰 검증
   - 만료 시간 확인 및 페이로드 파싱

2. **사용자 정보 로드**
   - 토큰의 sub (사용자 ID)로 사용자 정보 조회
   - `user_status`가 'active'인지 확인
   - `req.user`에 사용자 정보 저장

3. **에러 처리**
   - 토큰 없음: 401 Unauthorized
   - 유효하지 않은 토큰: 401 Unauthorized  
   - 비활성 사용자: 403 Forbidden

#### **역할 기반 접근 제어 (RBAC)**
```typescript
// middleware/authorization.middleware.ts
```

#### **관리자 권한 검증**
1. **역할 확인**
   - `user_role` 필드 검증 ('admin', 'shop_owner', 'user')
   - 요청된 리소스에 대한 권한 매트릭스 확인

2. **샵 소유자 권한**
   - 샵 관련 API 접근 시 `owner_id` 일치 확인
   - 자신의 샵 데이터만 접근 가능하도록 제한

#### **Rate Limiting 및 보안**
```typescript
// middleware/rateLimiter.middleware.ts
```

1. **API 속도 제한**
   - 사용자별 분당 요청 수 제한 (기본: 100req/min)
   - 로그인 API는 더 엄격한 제한 (5req/min)
   - Redis 또는 메모리 기반 카운터 사용

2. **보안 헤더**
   - Helmet.js로 기본 보안 헤더 설정
   - CORS 정책 설정 (허용된 도메인만)
   - XSS, CSRF 보호 헤더 적용

---

## 📱 하이브리드 앱 API 엔드포인트 (React/Next.js + Shadcn/UI)

### **1. 사용자 인증 관련 API**

#### **1.1 POST /api/auth/social-login**

##### **요청 구조**
```json
{
  "provider": "kakao|apple|google",
  "token": "소셜_로그인_토큰",
  "deviceInfo": {
    "platform": "ios|android",
    "version": "앱_버전",
    "deviceId": "기기_고유_ID"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 신규 사용자 생성 또는 기존 사용자 업데이트
INSERT INTO public.users (
    id, email, name, social_provider, social_provider_id,
    referral_code, last_login_at
) VALUES (
    $user_id, $email, $name, $provider, $provider_id,
    generate_referral_code(), NOW()
) ON CONFLICT (id) DO UPDATE SET
    last_login_at = NOW();

-- FCM 토큰 등록/업데이트
INSERT INTO public.push_tokens (user_id, token, platform)
VALUES ($user_id, $fcm_token, $platform)
ON CONFLICT (user_id, token) DO UPDATE SET
    last_used_at = NOW();
```

##### **비즈니스 로직**
1. **소셜 토큰 검증**
   - 각 제공자별 토큰 검증 API 호출
   - 사용자 기본 정보 추출 (이메일, 이름)

2. **Supabase Auth 연동**
   - 소셜 로그인 정보로 Supabase 사용자 생성/로그인
   - JWT 토큰 발급 및 반환

3. **기기 정보 저장**
   - FCM 토큰 등록 (푸시 알림용)
   - 기기별 로그인 이력 추적

#### **1.2 POST /api/auth/register**

##### **요청 구조**
```json
{
  "name": "사용자_실명",
  "gender": "male|female|other|prefer_not_to_say",
  "birthDate": "1990-01-01",
  "phoneNumber": "010-1234-5678",
  "phoneVerified": true,
  "referralCode": "ABCD1234",
  "termsAccepted": true,
  "privacyAccepted": true,
  "marketingConsent": false
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 정보 업데이트
UPDATE public.users SET
    name = $name,
    gender = $gender::user_gender,
    birth_date = $birth_date,
    phone_number = $phone_number,
    phone_verified = $phone_verified,
    referred_by_code = $referral_code,
    terms_accepted_at = NOW(),
    privacy_accepted_at = NOW(),
    marketing_consent = $marketing_consent
WHERE id = auth.uid();

-- 추천인 통계 업데이트
UPDATE public.users SET 
    total_referrals = total_referrals + 1
WHERE referral_code = $referred_by_code;
```

##### **비즈니스 로직**
1. **입력 데이터 검증**
   - Joi 스키마로 모든 필드 검증
   - 전화번호 형식 검증 (한국 형식)
   - 생년월일 유효성 검사

2. **추천인 코드 처리**
   - 입력된 추천인 코드 존재 여부 확인
   - 추천인의 `total_referrals` 카운트 증가
   - 추천 관계 기록 저장

### **2. 홈 화면 관련 API**

#### **2.1 GET /api/shops/nearby**

##### **쿼리 파라미터**
```
?latitude=37.5665&longitude=126.9780&radius=10000&limit=30&offset=0&category=nail&partnered=true
```

##### **데이터베이스 상호작용**
```sql
-- 위치 기반 샵 조회 (PRD 2.1 알고리즘 적용)
SELECT s.*, 
       ST_Distance(s.location, ST_Point($longitude, $latitude)::geography) as distance,
       COUNT(r.id) as total_bookings,
       AVG(rv.rating) as average_rating,
       si.image_url as main_image
FROM public.shops s
LEFT JOIN public.reservations r ON s.id = r.shop_id
LEFT JOIN public.reviews rv ON s.id = rv.shop_id AND rv.status = 'active'
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE s.shop_status = 'active'
  AND ST_DWithin(s.location, ST_Point($longitude, $latitude)::geography, $radius)
  AND ($category IS NULL OR s.main_category = $category::service_category)
  AND ($partnered IS NULL OR s.shop_type = CASE WHEN $partnered THEN 'partnered' ELSE 'non_partnered' END)
GROUP BY s.id, si.image_url
ORDER BY 
  CASE WHEN s.shop_type = 'partnered' THEN 0 ELSE 1 END,
  s.partnership_started_at DESC,
  distance ASC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **위치 기반 필터링**
   - PostGIS `ST_DWithin` 함수로 지정 반경 내 샵 조회
   - GPS 좌표를 GEOGRAPHY 타입으로 변환

2. **우선 순위 알고리즘**
   - 입점샵 (`shop_type = 'partnered'`) 최우선 노출
   - 입점샵 내에서는 최신 입점순 정렬
   - 비입점샵은 거리순 정렬

3. **성능 최적화**
   - 공간 인덱스 활용으로 빠른 위치 검색
   - 페이징으로 초기 로딩 시간 단축

#### **2.2 GET /api/user/favorites**

##### **데이터베이스 상호작용**
```sql
-- 사용자 즐겨찾기 샵 조회
SELECT s.*, uf.created_at as favorited_at,
       si.image_url as main_image
FROM public.user_favorites uf
JOIN public.shops s ON uf.shop_id = s.id
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE uf.user_id = $user_id AND s.shop_status = 'active'
ORDER BY uf.created_at DESC;
```

##### **비즈니스 로직**
- JWT 토큰에서 사용자 ID 추출
- 즐겨찾기한 순서대로 정렬
- 비활성화된 샵은 제외

### **3. 샵 상세 정보 API**

#### **3.1 GET /api/shops/:shopId**

##### **데이터베이스 상호작용**
```sql
-- 샵 상세 정보 조회
SELECT s.*,
       array_agg(DISTINCT si.image_url ORDER BY si.display_order) as shop_images,
       COUNT(DISTINCT r.id) as total_reviews,
       AVG(rv.rating) as average_rating,
       COUNT(DISTINCT res.id) as total_bookings
FROM public.shops s
LEFT JOIN public.shop_images si ON s.id = si.shop_id
LEFT JOIN public.reviews r ON s.id = r.shop_id AND r.status = 'active'
LEFT JOIN public.reservations res ON s.id = res.shop_id
WHERE s.id = $shop_id AND s.shop_status = 'active'
GROUP BY s.id;

-- 샵 서비스 목록
SELECT ss.*, 
       array_agg(ssi.image_url ORDER BY ssi.display_order) as service_images
FROM public.shop_services ss
LEFT JOIN public.service_images ssi ON ss.id = ssi.service_id
WHERE ss.shop_id = $shop_id AND ss.is_available = true
GROUP BY ss.id
ORDER BY ss.display_order, ss.category;
```

##### **비즈니스 로직**
1. **종합 정보 제공**
   - 샵 기본 정보 + 이미지 + 통계 데이터 통합
   - 서비스별 이미지와 가격 정보 포함

2. **영업시간 계산**
   - `operating_hours` JSONB 파싱
   - 현재 시간 기준 영업 상태 계산

#### **3.2 POST /api/shops/:shopId/favorite**

##### **데이터베이스 상호작용**
```sql
-- 즐겨찾기 추가/제거 토글
INSERT INTO public.user_favorites (user_id, shop_id)
VALUES ($user_id, $shop_id)
ON CONFLICT (user_id, shop_id) DO NOTHING;

-- 즐겨찾기 제거 (이미 존재하는 경우)
DELETE FROM public.user_favorites 
WHERE user_id = $user_id AND shop_id = $shop_id;
```

##### **비즈니스 로직**
- 현재 즐겨찾기 상태 확인 후 토글
- 동시성 제어를 위한 트랜잭션 처리

### **4. 예약 시스템 API**

#### **4.1 GET /api/shops/:shopId/available-slots**

##### **쿼리 파라미터**
```
?date=2024-03-15&serviceIds[]=uuid1&serviceIds[]=uuid2
```

##### **데이터베이스 상호작용**
```sql
-- 예약 가능한 시간 슬롯 조회
WITH time_slots AS (
    SELECT generate_series(
        $date::date + interval '9 hours',
        $date::date + interval '18 hours',
        interval '30 minutes'
    ) as slot_time
),
booked_slots AS (
    SELECT reservation_datetime
    FROM public.reservations
    WHERE shop_id = $shop_id 
      AND reservation_date = $date
      AND status IN ('confirmed', 'requested')
),
service_duration AS (
    SELECT MAX(duration_minutes) as max_duration
    FROM public.shop_services
    WHERE id = ANY($service_ids)
)
SELECT ts.slot_time
FROM time_slots ts
CROSS JOIN service_duration sd
WHERE NOT EXISTS (
    SELECT 1 FROM booked_slots bs
    WHERE bs.reservation_datetime BETWEEN 
        ts.slot_time AND ts.slot_time + (sd.max_duration || ' minutes')::interval
);
```

##### **비즈니스 로직**
1. **시간 슬롯 생성**
   - 영업시간 기반 30분 간격 슬롯 생성
   - 선택된 서비스 소요시간 고려

2. **예약 충돌 방지**
   - 기존 예약과 겹치는 시간 제외
   - 서비스 소요시간만큼 버퍼 적용

#### **4.2 POST /api/reservations**

##### **요청 구조**
```json
{
  "shopId": "uuid",
  "services": [
    {
      "serviceId": "uuid",
      "quantity": 1
    }
  ],
  "reservationDate": "2024-03-15",
  "reservationTime": "14:00",
  "specialRequests": "특별 요청사항",
  "pointsToUse": 5000
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 생성 트랜잭션
BEGIN;

-- 예약 메인 정보 생성
INSERT INTO public.reservations (
    user_id, shop_id, reservation_date, reservation_time,
    total_amount, deposit_amount, points_used, special_requests,
    status
) VALUES (
    $user_id, $shop_id, $date, $time,
    $total_amount, $deposit_amount, $points_used, $requests,
    'requested'
) RETURNING id;

-- 예약 서비스 연결
INSERT INTO public.reservation_services (
    reservation_id, service_id, quantity, unit_price, total_price
) VALUES ($reservation_id, $service_id, $quantity, $unit_price, $total_price);

-- 포인트 사용 처리
INSERT INTO public.point_transactions (
    user_id, reservation_id, transaction_type, amount, status
) VALUES (
    $user_id, $reservation_id, 'used_service', -$points_used, 'available'
);

COMMIT;
```

##### **비즈니스 로직**
1. **가격 계산**
   - 선택된 서비스들의 총액 계산
   - 포인트 할인 적용 (사용 가능 포인트 확인)
   - 예약금 비율 계산 (보통 20-30%)

2. **재고 및 시간 확인**
   - 요청된 시간 슬롯 재확인
   - 동시 예약 방지를 위한 락 처리

3. **예약 요청 처리 (v3.1 업데이트)**
   - **중요**: 사용자가 제출하는 것은 '확정된 예약'이 아닌 '예약 요청'
   - 예약 상태는 'requested'로 시작하여 샵 사장의 확정 대기
   - 사용자에게 "예약 요청이 완료되었습니다. 사장님 확인 후 확정됩니다" 알림
   - 샵 사장에게 새 예약 요청 승인 알림 발송

### **5. 결제 시스템 API**

#### **5.1 POST /api/payments/toss/prepare**

##### **요청 구조**
```json
{
  "reservationId": "uuid",
  "paymentMethod": "toss_payments",
  "amount": 50000,
  "isDeposit": true
}
```

##### **토스페이먼츠 연동**
```typescript
// 토스페이먼츠 결제 준비
const tossResponse = await fetch('https://api.tosspayments.com/v1/payments', {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    amount: amount,
    orderId: `order_${reservationId}_${Date.now()}`,
    orderName: `에뷰리띵 예약금 결제`,
    customerName: user.name,
    customerEmail: user.email
  })
});
```

##### **데이터베이스 상호작용**
```sql
-- 결제 정보 생성
INSERT INTO public.payments (
    reservation_id, user_id, payment_method, amount,
    payment_provider, provider_order_id, is_deposit,
    payment_status
) VALUES (
    $reservation_id, $user_id, $payment_method, $amount,
    'toss_payments', $order_id, $is_deposit,
    'pending'
) RETURNING id;
```

#### **5.2 POST /api/payments/toss/confirm**

##### **토스페이먼츠 결제 승인**
```typescript
const confirmResponse = await fetch(`https://api.tosspayments.com/v1/payments/confirm`, {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    paymentKey: paymentKey,
    orderId: orderId,
    amount: amount
  })
});
```

##### **결제 완료 후 처리**
```sql
-- 결제 상태 업데이트
UPDATE public.payments SET
    payment_status = 'deposit_paid',
    provider_transaction_id = $transaction_id,
    paid_at = NOW()
WHERE provider_order_id = $order_id;

-- 예약 상태는 'requested' 유지 (v3.1 정책)
-- 샵 사장의 수동 확정까지 대기
UPDATE public.reservations SET
    updated_at = NOW()
WHERE id = $reservation_id;

-- 알림 발송
-- 사용자: "예약금 결제 완료, 사장님 확인 대기 중"
-- 샵 사장: "새 예약 요청이 있습니다"

-- 포인트 적립은 서비스 완료 시에만 실행 (여기서는 제거)
```

### **6. 포인트 시스템 API**

#### **6.1 GET /api/user/points**

##### **응답 구조**
```json
{
  "totalPoints": 15000,
  "availablePoints": 12000,
  "pendingPoints": 3000,
  "pointsThisMonth": 5000,
  "transactions": [...]
}
```

##### **데이터베이스 상호작용**
```sql
-- 포인트 요약 정보 조회
SELECT u.total_points, u.available_points,
       COALESCE(pending.pending_points, 0) as pending_points,
       COALESCE(this_month.points_this_month, 0) as points_this_month
FROM public.users u
LEFT JOIN (
    SELECT user_id, SUM(amount) as pending_points
    FROM public.point_transactions 
    WHERE status = 'pending' AND amount > 0
    GROUP BY user_id
) pending ON u.id = pending.user_id
LEFT JOIN (
    SELECT user_id, SUM(amount) as points_this_month
    FROM public.point_transactions 
    WHERE status = 'available' AND amount > 0
      AND created_at >= date_trunc('month', NOW())
    GROUP BY user_id
) this_month ON u.id = this_month.user_id
WHERE u.id = $user_id;
```

#### **6.2 POST /api/points/use**

##### **요청 구조**
```json
{
  "amount": 5000,
  "reservationId": "uuid",
  "description": "서비스 결제 사용"
}
```

##### **비즈니스 로직**
1. **포인트 적립 정책 (v3.2 업데이트)**
   - 총 시술 금액의 2.5% 적립
   - **적립 한도**: 결제액 30만원까지만 적립 대상
   - 예시 1: 20만원 결제 → 5,000 포인트 적립 (20만원 × 2.5%)
   - 예시 2: 40만원 결제 → 7,500 포인트 적립 (30만원 × 2.5%)

2. **포인트 사용 정책 (v3.2 업데이트)**
   - **사용 제한**: 적립 후 7일이 지난 후부터 사용 가능
   - 7일 유예 기간을 통한 정산 및 취소/환불 절차 안정화
   - 선입선출(FIFO) 방식으로 차감
   - 트랜잭션으로 원자성 보장

##### **데이터베이스 상호작용**
```sql
-- 포인트 사용 처리 (FIFO 방식)
WITH available_points AS (
    SELECT id, amount, available_from
    FROM public.point_transactions
    WHERE user_id = $user_id
      AND status = 'available'
      AND amount > 0
      AND (available_from IS NULL OR available_from <= NOW())
      AND (expires_at IS NULL OR expires_at > NOW())
    ORDER BY available_from ASC, created_at ASC
),
point_usage AS (
    SELECT id, 
           CASE 
               WHEN SUM(amount) OVER (ORDER BY available_from, created_at) <= $amount_to_use
               THEN amount
               ELSE GREATEST(0, $amount_to_use - (SUM(amount) OVER (ORDER BY available_from, created_at) - amount))
           END as amount_to_deduct
    FROM available_points
)
UPDATE public.point_transactions SET
    status = CASE 
        WHEN amount = pu.amount_to_deduct THEN 'used'
        ELSE 'available'
    END,
    amount = CASE 
        WHEN amount > pu.amount_to_deduct THEN amount - pu.amount_to_deduct
        ELSE amount
    END
FROM point_usage pu
WHERE public.point_transactions.id = pu.id
  AND pu.amount_to_deduct > 0;

-- 사용 내역 기록
INSERT INTO public.point_transactions (
    user_id, reservation_id, transaction_type, amount,
    description, status
) VALUES (
    $user_id, $reservation_id, 'used_service', -$amount_to_use,
    $description, 'used'
);

-- 포인트 사용 API 호출
SELECT use_points($user_id, $amount, $reservation_id, $description);
```

#### **6.3 POST /api/admin/points/adjust**

##### **요청 구조**
```json
{
  "userId": "uuid",
  "amount": 5000,
  "reason": "고객 문의로 인한 포인트 보상",
  "type": "add" // "add" 또는 "subtract"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "message": "포인트가 성공적으로 조정되었습니다",
  "adjustment": {
    "id": "uuid",
    "userId": "uuid",
    "amount": 5000,
    "type": "add",
    "reason": "고객 문의로 인한 포인트 보상",
    "previousBalance": 15000,
    "newBalance": 20000,
    "adjustedBy": "admin_uuid",
    "created_at": "2024-03-15T16:30:00Z"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 포인트 조정 트랜잭션
BEGIN;

-- 포인트 거래 내역 생성
INSERT INTO public.point_transactions (
    user_id, transaction_type, amount, description, 
    status, metadata
) VALUES (
    $user_id, 'adjusted', $amount, $description,
    'available', jsonb_build_object('adjusted_by', $admin_id)
);

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'points_adjusted', 'user', $user_id,
    $reason, jsonb_build_object('amount', $amount)
);

COMMIT;
```

#### **6.4 GET /api/user/referral-earnings**

##### **쿼리 파라미터**
```
?start_date=2024-01-01&end_date=2024-12-31
```

##### **응답 구조**
```json
{
  "period": {
    "start_date": "2024-01-01",
    "end_date": "2024-12-31"
  },
  "summary": {
    "total_earnings": 531200,
    "total_referrals": 23,
    "successful_referrals": 18,
    "referral_code": "ABCD1234"
  },
  "referral_details": [
    {
      "referred_user_id": "masked_id_dbgusg",
      "masked_name": "dbgusg***",
      "registration_date": "2024-05-02",
      "earnings": [
        {
          "date": "2024-05-02",
          "amount": 150,
          "description": "첫 결제 완료 보너스"
        },
        {
          "date": "2024-06-12",
          "amount": 230,
          "description": "서비스 이용 적립"
        }
      ],
      "total_earnings": 380
    }
  ]
}
```

##### **데이터베이스 상호작용**
```sql
-- 추천인 수익 조회 (기간별)
SELECT 
    u.id,
    CONCAT(LEFT(u.name, 3), '***') as masked_name,
    u.created_at as registration_date,
    pt.created_at as earning_date,
    pt.amount,
    pt.description
FROM public.users u
JOIN public.point_transactions pt ON u.id = pt.related_user_id
WHERE pt.user_id = $referrer_id
  AND pt.transaction_type = 'earned_referral'
  AND pt.created_at BETWEEN $start_date AND $end_date
ORDER BY u.created_at DESC, pt.created_at DESC;

-- 추천인 통계 요약
SELECT 
    COUNT(DISTINCT u.id) as total_referrals,
    COUNT(DISTINCT CASE WHEN p.id IS NOT NULL THEN u.id END) as successful_referrals,
    COALESCE(SUM(pt.amount), 0) as total_earnings
FROM public.users u
LEFT JOIN public.payments p ON u.id = p.user_id AND p.payment_status = 'fully_paid'
LEFT JOIN public.point_transactions pt ON pt.related_user_id = u.id 
    AND pt.transaction_type = 'earned_referral'
    AND pt.created_at BETWEEN $start_date AND $end_date
WHERE u.referred_by_code = (
    SELECT referral_code FROM public.users WHERE id = $user_id
);
```

##### **비즈니스 로직**
1. **개인정보 보호**
   - 추천한 친구들의 이름을 마스킹 처리 (예: dbgusg***)
   - 상세 수익 내역만 제공, 개인 정보는 노출하지 않음

2. **기간별 정산**
   - 달력 UI로 기간 설정 가능
   - 월별 자동 정산 및 수익 계산

#### **6.5 POST /api/admin/payments/partial-refund**

##### **요청 구조**
```json
{
  "paymentId": "uuid",
  "refundAmount": 25000,
  "reason": "고객 요청으로 인한 부분 환불",
  "refundMethod": "original" // "original" 또는 "points"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "message": "부분 환불이 처리되었습니다",
  "refund": {
    "id": "uuid",
    "paymentId": "uuid",
    "refundAmount": 25000,
    "reason": "고객 요청으로 인한 부분 환불",
    "refundMethod": "original",
    "status": "partially_refunded",
    "processedAt": "2024-03-15T16:30:00Z"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 부분 환불 처리
UPDATE public.payments 
SET payment_status = CASE 
    WHEN $refund_amount = amount THEN 'refunded'
    ELSE 'partially_refunded'
  END,
    refund_amount = $refund_amount,
    refunded_at = NOW(),
    metadata = jsonb_set(
      metadata, 
      '{refund_reason}', 
      to_jsonb($reason)
    )
WHERE id = $payment_id;

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'refund_processed', 'payment', $payment_id,
    $reason, jsonb_build_object('refund_amount', $refund_amount)
);
```

### **7. 소셜 피드 시스템 API (v3.2 신규)**

#### **7.1 GET /api/feed/posts**

##### **쿼리 파라미터**
```
?page=1&limit=20&location=서울시 강남구&category=nail&user_type=shop
```

##### **데이터베이스 상호작용**
```sql
-- 피드 게시물 조회 (위치 및 카테고리 필터링)
SELECT p.*, u.name as author_name, u.profile_image_url,
       u.is_influencer, u.user_role,
       COUNT(l.id) as like_count,
       COUNT(c.id) as comment_count,
       array_agg(pi.image_url ORDER BY pi.display_order) as post_images
FROM public.feed_posts p
JOIN public.users u ON p.author_id = u.id
LEFT JOIN public.post_likes l ON p.id = l.post_id
LEFT JOIN public.post_comments c ON p.id = c.post_id AND c.status = 'active'
LEFT JOIN public.post_images pi ON p.id = pi.post_id
WHERE p.status = 'active'
  AND ($location IS NULL OR p.location_tag ILIKE '%' || $location || '%')
  AND ($category IS NULL OR p.category = $category::service_category)
  AND ($user_type IS NULL OR u.user_role = $user_type::user_role)
GROUP BY p.id, u.id
ORDER BY p.created_at DESC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **위치 기반 필터링**
   - 사용자 위치 또는 선택한 지역 기반 게시물 노출
   - 전체/특정 지역 선택 가능

2. **콘텐츠 타입별 분류**
   - 샵 홍보 게시물, 인플루언서 리뷰, 일반 사용자 후기 구분
   - 카테고리별 필터링 (네일, 속눈썹 등)

#### **7.2 POST /api/feed/posts**

##### **요청 구조**
```json
{
  "content": "오늘 받은 네일아트 너무 예뻐요! #네일아트 #강남",
  "images": ["image1.jpg", "image2.jpg"],
  "category": "nail",
  "location_tag": "서울시 강남구",
  "tagged_shop_id": "uuid",
  "hashtags": ["네일아트", "강남"]
}
```

##### **데이터베이스 상호작용**
```sql
-- 피드 게시물 생성
INSERT INTO public.feed_posts (
    author_id, content, category, location_tag,
    tagged_shop_id, hashtags, status
) VALUES (
    $user_id, $content, $category::service_category, $location_tag,
    $tagged_shop_id, $hashtags, 'active'
) RETURNING id;

-- 게시물 이미지 연결
INSERT INTO public.post_images (post_id, image_url, display_order)
VALUES ($post_id, $image_url, $order);
```

#### **7.3 POST /api/feed/posts/:postId/like**

##### **데이터베이스 상호작용**
```sql
-- 좋아요 토글 처리
INSERT INTO public.post_likes (user_id, post_id)
VALUES ($user_id, $post_id)
ON CONFLICT (user_id, post_id) DO NOTHING;

-- 이미 좋아요한 경우 제거
DELETE FROM public.post_likes 
WHERE user_id = $user_id AND post_id = $post_id
AND EXISTS (SELECT 1 FROM public.post_likes WHERE user_id = $user_id AND post_id = $post_id);
```

#### **7.4 POST /api/feed/posts/:postId/comments**

##### **요청 구조**
```json
{
  "content": "정말 예쁘네요! 어느 샵에서 받으셨나요?",
  "parent_comment_id": null
}
```

##### **데이터베이스 상호작용**
```sql
-- 댓글 생성
INSERT INTO public.post_comments (
    post_id, user_id, content, parent_comment_id, status
) VALUES (
    $post_id, $user_id, $content, $parent_comment_id, 'active'
);
```

#### **7.5 GET /api/feed/posts/:postId**

##### **데이터베이스 상호작용**
```sql
-- 게시물 조회 시 조회수 증가
UPDATE public.feed_posts SET 
    view_count = view_count + 1,
    updated_at = NOW() AT TIME ZONE 'Asia/Seoul'
WHERE id = $post_id AND status = 'active';

-- 게시물 상세 정보 조회
SELECT p.*, u.name as author_name, u.profile_image_url,
       u.is_influencer, u.user_role,
       s.name as tagged_shop_name,
       array_agg(pi.image_url ORDER BY pi.display_order) as post_images,
       EXISTS(
           SELECT 1 FROM public.post_likes 
           WHERE post_id = p.id AND user_id = $current_user_id
       ) as is_liked_by_me
FROM public.feed_posts p
JOIN public.users u ON p.author_id = u.id
LEFT JOIN public.shops s ON p.tagged_shop_id = s.id
LEFT JOIN public.post_images pi ON p.id = pi.post_id
WHERE p.id = $post_id AND p.status = 'active'
GROUP BY p.id, u.id, s.id;
```

##### **응답 구조**
```json
{
  "post": {
    "id": "uuid",
    "author": {
      "id": "uuid",
      "name": "홍길동",
      "profile_image_url": "https://...",
      "is_influencer": false,
      "user_role": "user"
    },
    "content": "오늘 받은 네일아트 너무 예뻐요!",
    "images": ["https://image1.jpg", "https://image2.jpg"],
    "category": "nail",
    "location_tag": "서울시 강남구",
    "tagged_shop": {
      "id": "uuid",
      "name": "네일샵 ABC"
    },
    "hashtags": ["네일아트", "강남"],
    "like_count": 15,
    "comment_count": 8,
    "is_liked_by_me": true,
    "created_at": "2024-03-15T10:30:00Z"
  }
}
```

#### **7.6 PUT /api/feed/posts/:postId**

##### **요청 구조**
```json
{
  "content": "수정된 게시물 내용",
  "hashtags": ["업데이트", "네일아트"]
}
```

##### **비즈니스 로직**
- 작성자만 자신의 게시물 수정 가능
- 이미지는 수정 불가 (새 게시물 작성 권장)
- 수정 시간 기록

#### **7.7 DELETE /api/feed/posts/:postId**

##### **비즈니스 로직**
- 작성자 또는 관리자만 삭제 가능
- Soft delete (status를 'deleted'로 변경)
- 관련 좋아요, 댓글도 함께 처리

#### **7.8 POST /api/feed/posts/:postId/report**

##### **요청 구조**
```json
{
  "reason": "spam", // "spam" | "inappropriate_content" | "harassment" | "other"
  "description": "스팸성 광고 게시물입니다"
}
```

##### **비즈니스 로직**
- 신고 횟수가 5회 이상 시 자동으로 게시물 숨김 처리
- 관리자에게 검토 알림 발송

### **8. 예약 취소 및 환불 API (v3.2 신규)**

#### **8.1 POST /api/reservations/:reservationId/cancel**

##### **요청 구조**
```json
{
  "reason": "개인 사정으로 인한 취소",
  "cancellation_type": "user_request" // "user_request" | "shop_request" | "no_show"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "cancellation": {
    "reservation_id": "uuid",
    "cancellation_type": "user_request",
    "refund_policy": {
      "refund_percentage": 100,
      "refund_amount": 45000,
      "processing_time": "3-5 영업일"
    },
    "cancelled_at": "2024-03-15T16:30:00Z"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 취소 처리
UPDATE public.reservations SET
    status = CASE 
        WHEN $cancellation_type = 'user_request' THEN 'cancelled_by_user'
        WHEN $cancellation_type = 'shop_request' THEN 'cancelled_by_shop'
        WHEN $cancellation_type = 'no_show' THEN 'no_show'
    END,
    cancellation_reason = $reason,
    cancelled_at = NOW()
WHERE id = $reservation_id;

-- 환불 처리 (정책에 따라)
UPDATE public.payments SET
    payment_status = CASE 
        WHEN should_refund($reservation_id, $cancellation_type) THEN 'refunded'
        ELSE payment_status
    END,
    refunded_at = CASE 
        WHEN should_refund($reservation_id, $cancellation_type) THEN NOW()
        ELSE refunded_at
    END
WHERE reservation_id = $reservation_id;
```

##### **비즈니스 로직**
1. **환불 정책 (v3.2 section 2.6)**
   - **100% 환불**: 충분히 사전 취소하거나 샵 점주가 취소하는 경우
   - **환불 불가**: 노쇼(No-Show) 또는 예약 시간에 임박한 취소
   - **예외 처리**: 다양한 상황에 대한 유연한 대응

2. **취소 시점 기준**
   - 예약 시간 24시간 전: 100% 환불
   - 예약 시간 24시간 이내: 환불 불가 (정책에 따라 조정 가능)
   - 샵 사정으로 인한 취소: 항상 100% 환불

#### **8.2 GET /api/reservations/:reservationId/refund-eligibility**

##### **응답 구조**
```json
{
  "reservation_id": "uuid",
  "is_refundable": true,
  "refund_percentage": 100,
  "refund_amount": 45000,
  "policy_reason": "예약 시간 24시간 전까지 취소 가능",
  "deadline": "2024-03-14T14:00:00Z"
}
```

##### **비즈니스 로직**
- 현재 시간과 예약 시간을 비교하여 환불 가능 여부 계산
- 실시간으로 환불 정책 적용 상태 확인

### **9. 샵 예약 관리 API (v3.1 업데이트)**

#### **9.1 PUT /api/shop/reservations/:reservationId/confirm**

##### **요청 구조**
```json
{
  "action": "confirm", // "confirm" | "reject"
  "notes": "예약이 확정되었습니다. 정시에 방문해주세요."
}
```

##### **응답 구조**
```json
{
  "success": true,
  "reservation": {
    "id": "uuid",
    "status": "confirmed",
    "confirmed_at": "2024-03-15T16:30:00Z",
    "shop_notes": "예약이 확정되었습니다. 정시에 방문해주세요."
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 확정/거절 처리
UPDATE public.reservations SET
    status = CASE 
        WHEN $action = 'confirm' THEN 'confirmed'
        WHEN $action = 'reject' THEN 'cancelled_by_shop'
    END,
    confirmed_at = CASE 
        WHEN $action = 'confirm' THEN NOW()
        ELSE NULL
    END,
    cancellation_reason = CASE 
        WHEN $action = 'reject' THEN $notes
        ELSE NULL
    END,
    updated_at = NOW()
WHERE id = $reservation_id
  AND status = 'requested'; -- 요청 상태인 예약만 처리 가능
```

##### **비즈니스 로직**
1. **권한 확인**
   - 해당 샵의 소유자만 예약 확정/거절 가능
   - RLS 정책으로 자동 권한 검증

2. **상태 전환**
   - 'requested' → 'confirmed' (확정)
   - 'requested' → 'cancelled_by_shop' (거절)

3. **알림 발송**
   - 확정 시: 고객에게 예약 확정 알림
   - 거절 시: 고객에게 예약 거절 알림 및 환불 안내

#### **9.2 GET /api/shop/reservations/pending**

##### **응답 구조**
```json
{
  "pending_reservations": [
    {
      "id": "uuid",
      "customer_name": "홍길동",
      "customer_phone": "010-1234-5678",
      "service_names": ["젤네일", "큐티클 케어"],
      "reservation_date": "2024-03-20",
      "reservation_time": "14:00",
      "total_amount": 65000,
      "deposit_paid": 20000,
      "special_requests": "색상은 핑크로 부탁드려요",
      "created_at": "2024-03-15T10:30:00Z"
    }
  ],
  "total_count": 5
}
```

##### **비즈니스 로직**
- 샵 소유자가 자신의 샵에 대한 대기 중인 예약 요청들을 확인
- 실시간 알림과 연동하여 새 예약 요청 즉시 확인 가능

#### **9.3 PUT /api/shop/reservations/:reservationId/complete**

##### **요청 구조**
```json
{
  "final_amount": 65000,
  "services_provided": [
    {
      "service_id": "uuid",
      "actual_price": 30000,
      "notes": "추가 디자인 적용"
    }
  ],
  "completion_notes": "서비스가 성공적으로 완료되었습니다"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "data": {
    "reservation": {
      "id": "uuid",
      "status": "completed",
      "completed_at": "2024-03-15T18:30:00Z",
      "final_amount": 65000,
      "points_awarded": 1625
    }
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 완료 처리 및 포인트 적립
BEGIN;

-- 예약 상태를 완료로 변경
UPDATE public.reservations SET
    status = 'completed',
    completed_at = NOW(),
    total_amount = $final_amount,
    updated_at = NOW()
WHERE id = $reservation_id
  AND status = 'confirmed'
  AND shop_id IN (
      SELECT id FROM public.shops WHERE owner_id = auth.uid()
  );

-- 잔금 결제 기록 생성 (필요시)
IF $remaining_amount > 0 THEN
    INSERT INTO public.payments (
        reservation_id, user_id, payment_method, amount,
        payment_status, is_deposit, paid_at
    ) VALUES (
        $reservation_id, $user_id, 'cash', $remaining_amount,
        'fully_paid', FALSE, NOW()
    );
    
    -- 기존 예약금 결제 상태도 fully_paid로 업데이트
    UPDATE public.payments SET
        payment_status = 'fully_paid'
    WHERE reservation_id = $reservation_id 
      AND is_deposit = TRUE 
      AND payment_status = 'deposit_paid';
END IF;

-- 포인트 적립 실행
SELECT award_service_points($reservation_id);

COMMIT;
```

##### **비즈니스 로직**
1. **권한 검증**
   - 해당 샵의 소유자만 완료 처리 가능
   - 'confirmed' 상태인 예약만 완료 가능

2. **포인트 적립 트리거**
   - 서비스 완료 시점에 포인트 적립
   - 인플루언서 보너스 자동 적용
   - 추천인 포인트 자동 지급

3. **알림 발송**
   - 고객에게 서비스 완료 및 포인트 적립 알림
   - 리뷰 작성 유도 알림 (향후 기능)

### **10. 샵 다이렉트 메시지 API (v3.2 신규)**

#### **10.1 GET /api/shops/:shopId/contact-info**

##### **응답 구조**
```json
{
  "shop_id": "uuid",
  "shop_name": "네일샵 ABC",
  "phone_number": "02-123-4567",
  "kakao_channel_url": "https://pf.kakao.com/_abc123",
  "instagram_handle": "@nailshop_abc",
  "contact_methods": [
    {
      "type": "kakao",
      "label": "카카오톡 채널",
      "url": "https://pf.kakao.com/_abc123",
      "is_primary": true
    },
    {
      "type": "phone",
      "label": "전화 문의",
      "value": "02-123-4567",
      "is_primary": false
    }
  ]
}
```

##### **데이터베이스 상호작용**
```sql
-- 샵 연락처 정보 조회
SELECT s.id, s.name, s.phone_number, s.kakao_channel_url,
       sc.contact_methods
FROM public.shops s
LEFT JOIN public.shop_contacts sc ON s.id = sc.shop_id
WHERE s.id = $shop_id AND s.shop_status = 'active';
```

### **11. 알림 관리 API (신규 추가)**

#### **11.1 GET /api/user/notifications**

##### **쿼리 파라미터**
```
?page=1&limit=20&status=unread&type=reservation_confirmed
```

##### **응답 구조**
```json
{
  "notifications": [
    {
      "id": "uuid",
      "type": "reservation_confirmed",
      "title": "예약이 확정되었습니다",
      "message": "ABC 네일샵 예약이 확정되었습니다.",
      "status": "unread",
      "related_id": "reservation_uuid",
      "action_url": "/reservations/uuid",
      "created_at": "2024-03-15T16:30:00Z"
    }
  ],
  "unread_count": 3,
  "total_count": 25
}
```

#### **11.2 GET /api/user/notifications/unread-count**

##### **응답 구조**
```json
{
  "unread_count": 5
}
```

#### **11.3 PUT /api/user/notifications/:notificationId/read**

##### **비즈니스 로직**
- 알림을 읽음 상태로 변경
- 읽은 시간 기록

#### **11.4 POST /api/shops/:shopId/report**

##### **요청 구조**
```json
{
  "reason": "inappropriate_content",
  "description": "부적절한 이미지가 포함되어 있습니다"
}
```

##### **비즈니스 로직**
- 샵 신고 접수
- 신고 횟수 누적
- 관리자에게 검토 알림

#### **11.5 GET /api/user/profile**

##### **응답 구조**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "name": "홍길동",
      "email": "hong@example.com",
      "phone_number": "010-1234-5678",
      "profile_image_url": "https://...",
      "is_influencer": true,
      "user_role": "user",
      "total_points": 15000,
      "available_points": 12000,
      "referral_code": "ABCD1234",
      "total_referrals": 23,
      "successful_referrals": 18
    }
  }
}
```

#### **11.6 PUT /api/user/profile**

##### **요청 구조**
```json
{
  "name": "홍길동",
  "nickname": "길동이",
  "profile_image_url": "https://new-image.jpg"
}
```

##### **비즈니스 로직**
- 사용자 자신의 프로필만 수정 가능
- 실명 변경 시 재인증 필요 (향후 기능)

#### **11.7 POST /api/auth/change-password**

##### **요청 구조**
```json
{
  "current_password": "old_password",
  "new_password": "new_secure_password"
}
```

##### **비즈니스 로직**
- Supabase Auth와 연동
- 비밀번호 강도 검증
- 변경 성공 시 모든 기기에서 재로그인 필요

#### **11.8 GET /api/admin/health**

##### **응답 구조**
```json
{
  "success": true,
  "data": {
    "status": "healthy",
    "timestamp": "2024-03-15T16:30:00Z",
    "version": "3.2.0",
    "checks": {
      "database": {
        "status": "healthy",
        "response_time_ms": 45
      },
      "supabase": {
        "status": "healthy",
        "response_time_ms": 120
      },
      "toss_payments": {
        "status": "healthy",
        "response_time_ms": 200
      },
      "storage": {
        "status": "healthy",
        "response_time_ms": 80
      }
    },
    "metrics": {
      "active_users_24h": 1250,
      "reservations_today": 45,
      "api_requests_per_minute": 150,
      "error_rate_percent": 0.2
    }
  }
}
```

##### **비즈니스 로직**
- 시스템 상태 종합 모니터링
- 외부 서비스 연결 상태 확인
- 성능 메트릭 실시간 제공

---

## 🖥️ 웹 관리자 API 엔드포인트

### **1. 관리자 인증 API**

#### **1.1 POST /api/admin/login**

##### **요청 구조**
```json
{
  "email": "admin@ebeautything.com",
  "password": "secure_password"
}
```

##### **데이터베이스 상호작용**
```sql
-- 관리자 계정 확인
SELECT id, email, name, user_role 
FROM public.users 
WHERE email = $email 
  AND user_role IN ('admin', 'shop_owner')
  AND user_status = 'active';
```

##### **비즈니스 로직**
1. **이메일/비밀번호 검증**
   - Supabase Auth로 인증 처리
   - 관리자 역할 확인

2. **세션 관리**
   - JWT 토큰 발급 (longer expiry for admin)
   - 로그인 이력 기록
   - 다중 디바이스 로그인 정책 (최대 3개 디바이스)
   - 자동 토큰 갱신 (30분 간격)

3. **보안 강화**
   - 로그인 시도 제한 (5회 실패 시 30분 잠금)
   - IP 기반 접근 제한 (관리자 전용 IP 설정 가능)
   - 세션 타임아웃 (1시간 비활성 시 자동 로그아웃)

### **2. 사용자 관리 API (Super Admin)**

#### **2.1 GET /api/admin/users**

##### **쿼리 파라미터**
```
?page=1&limit=50&search=홍길동&status=active&role=user&sortBy=created_at&sortOrder=desc
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 목록 조회 (검색 및 필터 적용)
SELECT u.id, u.name, u.email, u.phone_number, u.user_status, 
       u.user_role, u.is_influencer, u.total_points, u.total_referrals,
       u.created_at, u.last_login_at,
       COUNT(r.id) as total_reservations
FROM public.users u
LEFT JOIN public.reservations r ON u.id = r.user_id
WHERE ($search IS NULL OR u.name ILIKE '%' || $search || '%' 
                        OR u.email ILIKE '%' || $search || '%')
  AND ($status IS NULL OR u.user_status = $status::user_status)
  AND ($role IS NULL OR u.user_role = $role::user_role)
GROUP BY u.id
ORDER BY 
  CASE WHEN $sortBy = 'created_at' THEN u.created_at END ASC/DESC,
  CASE WHEN $sortBy = 'name' THEN u.name END ASC/DESC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **검색 기능**
   - 이름, 이메일, 전화번호로 검색
   - ILIKE를 사용한 대소문자 무관 검색

2. **필터링 및 정렬**
   - 상태별, 역할별 필터
   - 다양한 컬럼으로 정렬 지원

#### **2.2 PUT /api/admin/users/:userId/status**

##### **요청 구조**
```json
{
  "status": "suspended",
  "reason": "스팸 신고 다수 접수"
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 상태 변경
UPDATE public.users SET
    user_status = $status::user_status,
    updated_at = NOW()
WHERE id = $user_id;

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 'user_suspended', 'user', $user_id, $reason
);
```

### **3. 샵 관리 API**

#### **3.1 GET /api/admin/shops/pending**

##### **데이터베이스 상호작용**
```sql
-- 승인 대기 중인 샵 목록
SELECT s.id, s.name, s.owner_id, s.address, s.main_category,
       s.business_license_number, s.business_license_image_url,
       s.verification_status, s.created_at,
       u.name as owner_name, u.email as owner_email
FROM public.shops s
JOIN public.users u ON s.owner_id = u.id
WHERE s.verification_status = 'pending'
ORDER BY s.created_at ASC;
```

#### **3.2 PUT /api/admin/shops/:shopId/approve**

##### **요청 구조**
```json
{
  "approved": true,
  "shopType": "partnered",
  "commissionRate": 10.0,
  "notes": "승인 완료"
}
```

##### **데이터베이스 상호작용**
```sql
-- 샵 승인 처리
UPDATE public.shops SET
    verification_status = CASE WHEN $approved THEN 'verified' ELSE 'rejected' END,
    shop_status = CASE WHEN $approved THEN 'active' ELSE 'inactive' END,
    shop_type = $shop_type::shop_type,
    commission_rate = $commission_rate,
    partnership_started_at = CASE WHEN $approved THEN NOW() ELSE NULL END
WHERE id = $shop_id;

-- 관리자 액션 로그
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 
    CASE WHEN $approved THEN 'shop_approved' ELSE 'shop_rejected' END,
    'shop', $shop_id, $notes
);
```

##### **비즈니스 로직**
1. **승인 처리**
   - 승인 시 샵 상태를 'active'로 변경
   - 파트너십 타입 및 수수료율 설정

2. **알림 발송**
   - 샵 오너에게 승인/거절 알림 발송
   - 승인 시 환영 메시지 및 가이드 제공

### **4. 예약 관리 API**

#### **4.1 GET /api/admin/reservations**

##### **쿼리 파라미터**
```
?shopId=uuid&status=confirmed&startDate=2024-03-01&endDate=2024-03-31&page=1&limit=50
```

##### **데이터베이스 상호작용**
```sql
-- 예약 목록 조회 (관리자/샵 오너별 권한 적용)
SELECT r.id, r.reservation_date, r.reservation_time, r.status,
       r.total_amount, r.deposit_amount, r.points_used,
       u.name as customer_name, u.phone_number as customer_phone,
       s.name as shop_name, s.id as shop_id,
       array_agg(ss.name) as service_names
FROM public.reservations r
JOIN public.users u ON r.user_id = u.id
JOIN public.shops s ON r.shop_id = s.id
JOIN public.reservation_services rs ON r.id = rs.reservation_id
JOIN public.shop_services ss ON rs.service_id = ss.id
WHERE ($shop_id IS NULL OR r.shop_id = $shop_id)
  AND ($status IS NULL OR r.status = $status::reservation_status)
  AND ($start_date IS NULL OR r.reservation_date >= $start_date)
  AND ($end_date IS NULL OR r.reservation_date <= $end_date)
  AND (
    $admin_role = 'admin' OR 
    (s.owner_id = $admin_id AND $admin_role = 'shop_owner')
  )
GROUP BY r.id, u.id, s.id
ORDER BY r.reservation_datetime DESC
LIMIT $limit OFFSET $offset;
```

#### **4.2 PUT /api/admin/reservations/:reservationId/status**

##### **요청 구조**
```json
{
  "status": "confirmed",
  "notes": "예약 확정되었습니다"
}
```

##### **비즈니스 로직**
1. **상태 변경 권한 확인**
   - Super Admin: 모든 예약 관리 가능
   - Shop Owner: 자신의 샵 예약만 관리

2. **상태별 처리 로직**
   - confirmed: 고객에게 확정 알림
   - completed: 포인트 적립 처리
   - cancelled: 환불 처리 트리거

### **5. 결제 및 정산 API (Super Admin)**

#### **5.1 GET /api/admin/payments/summary**

##### **쿼리 파라미터**
```
?startDate=2024-03-01&endDate=2024-03-31&shopId=uuid
```

##### **데이터베이스 상호작용**
```sql
-- 결제 요약 통계
SELECT 
    DATE_TRUNC('day', p.paid_at) as payment_date,
    COUNT(*) as transaction_count,
    SUM(p.amount) as total_amount,
    SUM(CASE WHEN p.is_deposit THEN p.amount ELSE 0 END) as deposit_amount,
    SUM(CASE WHEN NOT p.is_deposit THEN p.amount ELSE 0 END) as full_payment_amount,
    COUNT(DISTINCT p.user_id) as unique_customers
FROM public.payments p
JOIN public.reservations r ON p.reservation_id = r.id
WHERE p.payment_status = 'fully_paid'
  AND p.paid_at BETWEEN $start_date AND $end_date
  AND ($shop_id IS NULL OR r.shop_id = $shop_id)
GROUP BY DATE_TRUNC('day', p.paid_at)
ORDER BY payment_date DESC;
```

#### **5.2 GET /api/admin/settlements**

##### **데이터베이스 상호작용**
```sql
-- 샵별 정산 내역
SELECT s.id, s.name, s.commission_rate,
       COUNT(r.id) as completed_reservations,
       SUM(r.total_amount) as gross_revenue,
       SUM(r.total_amount * s.commission_rate / 100) as commission_amount,
       SUM(r.total_amount * (100 - s.commission_rate) / 100) as net_payout
FROM public.shops s
JOIN public.reservations r ON s.id = r.shop_id
WHERE r.status = 'completed'
  AND r.completed_at BETWEEN $start_date AND $end_date
  AND s.shop_type = 'partnered'
GROUP BY s.id
ORDER BY gross_revenue DESC;
```

---

## 🔔 알림 시스템

### **푸시 알림 서비스**

#### **FCM 연동 구현**
```typescript
// services/notification.service.ts
class NotificationService {
  async sendPushNotification(
    userId: string, 
    title: string, 
    message: string,
    data?: any
  ) {
    // FCM 토큰 조회
    const tokens = await this.getUserFCMTokens(userId);
    
    // FCM 메시지 발송
    const fcmMessage = {
      notification: { title, body: message },
      data: data || {},
      tokens: tokens
    };
    
    return await admin.messaging().sendMulticast(fcmMessage);
  }
}
```

#### **알림 트리거 이벤트**
1. **예약 관련 알림**
   - 예약 요청 접수: 샵 오너에게 알림
   - 예약 확정: 고객에게 알림
   - 예약 취소: 양측에게 알림

2. **포인트 관련 알림**
   - 포인트 적립: 서비스 완료 후 고객에게
   - 포인트 만료 예정: 만료 7일 전 알림

3. **시스템 알림**
   - 새 공지사항: 전체 사용자
   - 마케팅 정보: 동의한 사용자만

### **실시간 알림 처리**

#### **웹소켓 연결 관리**
```typescript
// WebSocket을 통한 실시간 알림
io.on('connection', (socket) => {
  socket.on('join_admin_room', (adminId) => {
    socket.join(`admin_${adminId}`);
  });
  
  // 새 예약 알림
  socket.on('new_reservation', (data) => {
    io.to(`admin_${data.shopOwnerId}`).emit('reservation_alert', data);
  });
});
```

---

## 📊 분석 및 통계 API

### **대시보드 통계 API**

#### **GET /api/admin/analytics/dashboard**

##### **응답 구조**
```json
{
  "overview": {
    "totalUsers": 15420,
    "totalShops": 234,
    "totalReservations": 3421,
    "totalRevenue": 125000000
  },
  "growth": {
    "userGrowthRate": 12.5,
    "revenueGrowthRate": 8.3,
    "reservationGrowthRate": 15.2
  },
  "chartData": {
    "dailyRegistrations": [...],
    "monthlyRevenue": [...],
    "categoryDistribution": [...]
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 전체 플랫폼 통계
WITH current_month AS (
  SELECT COUNT(*) as users_this_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW())
),
previous_month AS (
  SELECT COUNT(*) as users_last_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW()) - interval '1 month'
    AND created_at < date_trunc('month', NOW())
)
SELECT 
  (SELECT COUNT(*) FROM public.users WHERE user_status = 'active') as total_users,
  (SELECT COUNT(*) FROM public.shops WHERE shop_status = 'active') as total_shops,
  (SELECT COUNT(*) FROM public.reservations) as total_reservations,
  (SELECT SUM(total_amount) FROM public.reservations WHERE status = 'completed') as total_revenue,
  (cm.users_this_month::float / NULLIF(pm.users_last_month, 0) - 1) * 100 as user_growth_rate
FROM current_month cm, previous_month pm;
```

#### **GET /api/admin/analytics/feed-metrics**

##### **응답 구조**
```json
{
  "success": true,
  "data": {
    "overview": {
      "total_posts": 1250,
      "total_likes": 15600,
      "total_comments": 3400,
      "active_users_today": 450
    },
    "engagement": {
      "average_likes_per_post": 12.5,
      "average_comments_per_post": 2.7,
      "top_hashtags": ["#네일아트", "#속눈썹", "#강남"],
      "viral_posts_count": 15
    },
    "moderation": {
      "reports_today": 8,
      "auto_hidden_posts": 2,
      "pending_reviews": 12
    }
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 피드 성과 분석
WITH post_stats AS (
  SELECT 
    COUNT(*) as total_posts,
    AVG(like_count) as avg_likes,
    AVG(comment_count) as avg_comments,
    SUM(view_count) as total_views
  FROM public.feed_posts 
  WHERE status = 'active' 
    AND created_at >= CURRENT_DATE
),
engagement_stats AS (
  SELECT 
    COUNT(DISTINCT user_id) as active_users_today
  FROM public.post_likes 
  WHERE created_at >= CURRENT_DATE
),
hashtag_stats AS (
  SELECT 
    unnest(hashtags) as hashtag,
    COUNT(*) as usage_count
  FROM public.feed_posts 
  WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
    AND status = 'active'
  GROUP BY unnest(hashtags)
  ORDER BY usage_count DESC
  LIMIT 10
)
SELECT * FROM post_stats, engagement_stats;
```

---

## 🛠️ 유틸리티 및 도우미 서비스

### **이메일 서비스**
```typescript
// services/email.service.ts
class EmailService {
  async sendWelcomeEmail(user: User) {
    // 환영 이메일 템플릿 발송
  }
  
  async sendReservationConfirmation(reservation: Reservation) {
    // 예약 확인 이메일 발송
  }
}
```

### **이미지 처리 서비스**
```typescript
// services/image.service.ts
class ImageService {
  async optimizeAndUpload(file: Buffer, path: string) {
    // 이미지 압축 및 Supabase Storage 업로드
    const optimized = await sharp(file)
      .resize(800, 600, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer();
      
    return await supabase.storage
      .from('shop-images')
      .upload(path, optimized);
  }
}
```

### **검색 서비스**
```typescript
// services/search.service.ts
class SearchService {
  async searchShops(query: string, filters: SearchFilters) {
    // 전문 검색 기능 구현
    // PostgreSQL Full-Text Search 활용
  }
}
```

---

## 🔧 에러 처리 및 로깅

### **표준화된 API 응답 형식 (v3.2 업데이트)**
```typescript
// 통합 API 응답 구조
interface StandardResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: Array<{
      field: string;
      message: string;
    }>;
    timestamp: string;
    requestId: string;
  };
  meta?: {
    pagination?: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
    filters?: Record<string, any>;
  };
}

// 성공 응답 예시
interface SuccessResponse<T> {
  success: true;
  data: T;
  meta?: {
    pagination?: PaginationMeta;
    filters?: Record<string, any>;
  };
}

// 에러 응답 예시
interface ErrorResponse {
  success: false;
  data: null;
  error: {
    code: string;
    message: string;
    details?: ValidationError[];
    timestamp: string;
    requestId: string;
  };
}

// 에러 코드 정의
const ERROR_CODES = {
  // 인증 관련 (1000-1999)
  UNAUTHORIZED: "AUTH_1001",
  TOKEN_EXPIRED: "AUTH_1002",
  INVALID_CREDENTIALS: "AUTH_1003",
  INSUFFICIENT_PERMISSIONS: "AUTH_1004",
  SESSION_TIMEOUT: "AUTH_1005",
  
  // 검증 관련 (2000-2999)
  VALIDATION_ERROR: "VALID_2001",
  MISSING_REQUIRED_FIELD: "VALID_2002",
  INVALID_FORMAT: "VALID_2003",
  INVALID_PHONE_FORMAT: "VALID_2004",
  INVALID_BUSINESS_LICENSE: "VALID_2005",
  
  // 비즈니스 로직 (3000-3999)
  RESOURCE_NOT_FOUND: "BUSINESS_3001",
  INVALID_STATE_TRANSITION: "BUSINESS_3002",
  INSUFFICIENT_POINTS: "BUSINESS_3003",
  SLOT_NOT_AVAILABLE: "BUSINESS_3004",
  CONCURRENT_BOOKING: "BUSINESS_3005",
  POINT_EXPIRED: "BUSINESS_3006",
  
  // 결제 관련 (4000-4999)
  PAYMENT_FAILED: "PAYMENT_4001",
  REFUND_FAILED: "PAYMENT_4002",
  INSUFFICIENT_FUNDS: "PAYMENT_4003",
  PARTIAL_REFUND_NOT_ALLOWED: "PAYMENT_4004",
  
  // 시스템 관련 (5000-5999)
  INTERNAL_SERVER_ERROR: "SYSTEM_5001",
  DATABASE_ERROR: "SYSTEM_5002",
  EXTERNAL_SERVICE_ERROR: "SYSTEM_5003"
};

// 통합 에러 처리
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  const requestId = req.headers['x-request-id'] as string || generateRequestId();
  
  logger.error({
    message: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method,
    user: req.user?.id,
    requestId
  });
  
  if (error instanceof ValidationError) {
    return res.status(400).json({
      success: false,
      error: {
        code: ERROR_CODES.VALIDATION_ERROR,
        message: "입력 데이터가 올바르지 않습니다",
        details: error.details,
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  if (error instanceof AuthenticationError) {
    return res.status(401).json({
      success: false,
      error: {
        code: ERROR_CODES.UNAUTHORIZED,
        message: "인증이 필요합니다",
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  // 기본 에러 응답
  return res.status(500).json({
    success: false,
    error: {
      code: ERROR_CODES.INTERNAL_SERVER_ERROR,
      message: "서버 내부 오류가 발생했습니다",
      timestamp: new Date().toISOString(),
      requestId
    }
  });
};
```

### **구조화된 로깅**
```typescript
// utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});
```

### **데이터 검증 규칙**
```typescript
// validators/common.validator.ts
import Joi from 'joi';

// 한국 전화번호 검증
export const phoneSchema = Joi.string()
  .pattern(/^01[0-9]-[0-9]{3,4}-[0-9]{4}$/)
  .message('올바른 한국 전화번호 형식이 아닙니다 (예: 010-1234-5678)');

// 사업자등록번호 검증
export const businessLicenseSchema = Joi.string()
  .pattern(/^[0-9]{3}-[0-9]{2}-[0-9]{5}$/)
  .message('올바른 사업자등록번호 형식이 아닙니다 (예: 123-45-67890)');

// 한국 주소 검증
export const addressSchema = Joi.string()
  .min(10)
  .max(200)
  .pattern(/^[가-힣\s]+시\s+[가-힣\s]+구\s+[가-힣\s]+동/)
  .message('올바른 한국 주소 형식이 아닙니다');

// 이미지 업로드 검증
export const imageSchema = Joi.object({
  fieldname: Joi.string().valid('image').required(),
  mimetype: Joi.string().valid('image/jpeg', 'image/png', 'image/webp').required(),
  size: Joi.number().max(5 * 1024 * 1024).required(), // 5MB 제한
  buffer: Joi.binary().required()
});

// 포인트 금액 검증
export const pointAmountSchema = Joi.number()
  .integer()
  .min(1)
  .max(1000000) // 최대 100만 포인트
  .required();

// 피드 콘텐츠 검증 (v3.2 신규)
export const feedContentSchema = Joi.object({
  content: Joi.string()
    .min(1)
    .max(2000) // 최대 2000자
    .required()
    .custom((value, helpers) => {
      // 기본적인 욕설 필터링 (실제로는 더 정교한 필터 필요)
      const profanityWords = ['욕설1', '욕설2']; // 실제 욕설 목록으로 교체
      const lowerValue = value.toLowerCase();
      for (const word of profanityWords) {
        if (lowerValue.includes(word)) {
          return helpers.error('content.profanity');
        }
      }
      return value;
    }, '부적절한 언어 검사'),
  
  hashtags: Joi.array()
    .items(Joi.string().max(50))
    .max(10), // 최대 10개 해시태그
    
  images: Joi.array()
    .items(Joi.string().uri())
    .max(10) // 최대 10개 이미지
});

// 전화번호 국제 형식 검증 (확장)
export const internationalPhoneSchema = Joi.string()
  .pattern(/^(\+82|0)(10|11|16|17|18|19)-?[0-9]{3,4}-?[0-9]{4}$/) // 한국
  .or(Joi.string().pattern(/^\+1[0-9]{10}$/)) // 미국
  .or(Joi.string().pattern(/^\+86[0-9]{11}$/)) // 중국
  .message('지원되지 않는 전화번호 형식입니다');

// 사업자등록번호 검증 (체크섬 포함)
export const businessLicenseValidationSchema = Joi.string()
  .pattern(/^[0-9]{3}-[0-9]{2}-[0-9]{5}$/)
  .custom((value, helpers) => {
    // 사업자등록번호 체크섬 검증 로직
    const numbers = value.replace(/-/g, '');
    const checkArray = [1, 3, 7, 1, 3, 7, 1, 3, 5];
    let sum = 0;
    
    for (let i = 0; i < 9; i++) {
      sum += parseInt(numbers[i]) * checkArray[i];
    }
    
    sum += Math.floor((parseInt(numbers[8]) * 5) / 10);
    const checkDigit = (10 - (sum % 10)) % 10;
    
    if (checkDigit !== parseInt(numbers[9])) {
      return helpers.error('business.invalid');
    }
    
    return value;
  }, '사업자등록번호 유효성 검사')
  .message('올바르지 않은 사업자등록번호입니다');

// Rate Limiting 설정 (v3.2 강화)
export const rateLimitConfig = {
  // 일반 API 요청
  general: {
    windowMs: 15 * 60 * 1000, // 15분
    max: 1000, // 요청 제한
    message: '너무 많은 요청이 발생했습니다. 잠시 후 다시 시도해주세요.'
  },
  
  // 로그인 시도
  auth: {
    windowMs: 15 * 60 * 1000, // 15분
    max: 5, // 5회 제한
    message: '로그인 시도가 너무 많습니다. 15분 후 다시 시도해주세요.'
  },
  
  // 피드 게시물 작성
  feedPost: {
    windowMs: 60 * 60 * 1000, // 1시간
    max: 10, // 10개 제한
    message: '게시물 작성이 너무 많습니다. 1시간 후 다시 시도해주세요.'
  },
  
  // 신고 접수
  report: {
    windowMs: 24 * 60 * 60 * 1000, // 24시간
    max: 5, // 5회 제한
    message: '신고 접수가 너무 많습니다. 24시간 후 다시 시도해주세요.'
  }
};

// 이미지 업로드 보안 검증
export const imageUploadSchema = Joi.object({
  fieldname: Joi.string().valid('image', 'profile_image', 'shop_image').required(),
  mimetype: Joi.string().valid(
    'image/jpeg', 
    'image/png', 
    'image/webp',
    'image/gif'
  ).required(),
  size: Joi.number().max(10 * 1024 * 1024).required(), // 10MB 제한
  buffer: Joi.binary().required()
}).custom((value, helpers) => {
  // 이미지 헤더 검증 (MIME 타입 위조 방지)
  const buffer = value.buffer;
  const jpegHeader = [0xFF, 0xD8, 0xFF];
  const pngHeader = [0x89, 0x50, 0x4E, 0x47];
  const webpHeader = [0x52, 0x49, 0x46, 0x46];
  const gifHeader = [0x47, 0x49, 0x46];
  
  const isValidJpeg = jpegHeader.every((byte, i) => buffer[i] === byte);
  const isValidPng = pngHeader.every((byte, i) => buffer[i] === byte);
  const isValidWebp = webpHeader.every((byte, i) => buffer[i] === byte);
  const isValidGif = gifHeader.every((byte, i) => buffer[i] === byte);
  
  if (!isValidJpeg && !isValidPng && !isValidWebp && !isValidGif) {
    return helpers.error('image.invalid_format');
  }
  
  return value;
}, '이미지 형식 검증');
```

### **포인트 시스템 비즈니스 로직**
```typescript
// services/point.service.ts
class PointService {
  // 포인트 만료 처리 (매일 자정 실행)
  async processPointExpiration() {
    const expiredPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'available')
      .lt('expires_at', new Date().toISOString());
    
    for (const point of expiredPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'expired',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // 7일 후 사용 가능 상태로 변경 (매일 자정 실행)
  async processPendingToAvailable() {
    const pendingPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'pending')
      .lte('available_from', new Date().toISOString());
    
    for (const point of pendingPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'available',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // 인플루언서 보너스 계산 (2배 적립)
  async calculateInfluencerBonus(userId: string, baseAmount: number) {
    const user = await supabase
      .from('users')
      .select('is_influencer')
      .eq('id', userId)
      .single();
    
    if (user.data?.is_influencer) {
      return baseAmount * 2; // 2배 보너스
    }
    
    return baseAmount;
  }
  
  // 관리자 포인트 조정
  async adjustPointsByAdmin(userId: string, amount: number, reason: string, adminId: string) {
    const transaction = await supabase
      .from('point_transactions')
      .insert({
        user_id: userId,
        transaction_type: 'adjusted',
        amount: amount,
        description: `관리자 조정: ${reason}`,
        status: 'available',
        metadata: { adjusted_by: adminId }
      });
    
    // 관리자 액션 로그 기록
    await supabase
      .from('admin_actions')
      .insert({
        admin_id: adminId,
        action_type: 'points_adjusted',
        target_type: 'user',
        target_id: userId,
        reason: reason,
        metadata: { amount, previous_balance: await this.getUserBalance(userId) }
      });
    
    return transaction;
  }
}
```

### **예약 시스템 비즈니스 로직**
```typescript
// services/reservation.service.ts
class ReservationService {
  // 동시 예약 방지
  async checkConcurrentBooking(shopId: string, date: string, time: string, duration: number) {
    const startTime = new Date(`${date} ${time}`);
    const endTime = new Date(startTime.getTime() + duration * 60000);
    
    const conflictingReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('shop_id', shopId)
      .eq('reservation_date', date)
      .in('status', ['requested', 'confirmed'])
      .overlaps('reservation_datetime', startTime.toISOString(), endTime.toISOString());
    
    return conflictingReservations.data?.length === 0;
  }
  
  // 노쇼 감지 (예약 시간 30분 후 자동 처리)
  async detectNoShow() {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    
    const noShowReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('status', 'confirmed')
      .lt('reservation_datetime', thirtyMinutesAgo.toISOString());
    
    for (const reservation of noShowReservations.data || []) {
      await supabase
        .from('reservations')
        .update({ 
          status: 'no_show',
          no_show_reason: '예약 시간 30분 경과로 노쇼 처리',
          updated_at: new Date().toISOString()
        })
        .eq('id', reservation.id);
    }
  }
  
  // 예약 재스케줄
  async rescheduleReservation(reservationId: string, newDate: string, newTime: string) {
    // 기존 예약 취소
    await this.cancelReservation(reservationId, 'rescheduled');
    
    // 새 예약 생성
    const originalReservation = await supabase
      .from('reservations')
      .select('*')
      .eq('id', reservationId)
      .single();
    
    return await supabase
      .from('reservations')
      .insert({
        user_id: originalReservation.data.user_id,
        shop_id: originalReservation.data.shop_id,
        reservation_date: newDate,
        reservation_time: newTime,
        status: 'requested',
        total_amount: originalReservation.data.total_amount,
        deposit_amount: originalReservation.data.deposit_amount,
        special_requests: originalReservation.data.special_requests
      });
  }
}
```

### **결제 시스템 비즈니스 로직**
```typescript
// services/payment.service.ts
class PaymentService {
  // 부분 환불 처리
  async processPartialRefund(paymentId: string, refundAmount: number, reason: string) {
    const payment = await supabase
      .from('payments')
      .select('*')
      .eq('id', paymentId)
      .single();
    
    if (refundAmount > payment.data.amount) {
      throw new Error('환불 금액이 결제 금액을 초과할 수 없습니다');
    }
    
    const newStatus = refundAmount === payment.data.amount ? 'refunded' : 'partially_refunded';
    
    return await supabase
      .from('payments')
      .update({
        payment_status: newStatus,
        refund_amount: refundAmount,
        refunded_at: new Date().toISOString(),
        metadata: { ...payment.data.metadata, refund_reason: reason }
      })
      .eq('id', paymentId);
  }
  
  // 수수료 계산 (실시간)
  async calculateCommission(shopId: string, amount: number) {
    const shop = await supabase
      .from('shops')
      .select('commission_rate, shop_type')
      .eq('id', shopId)
      .single();
    
    if (shop.data.shop_type === 'partnered') {
      return (amount * shop.data.commission_rate) / 100;
    }
    
    return 0; // 비입점샵은 수수료 없음
  }
  
  // 분할 결제 처리 (예약금 + 잔금)
  async processSplitPayment(reservationId: string, depositAmount: number, totalAmount: number) {
    // 예약금 결제
    const depositPayment = await supabase
      .from('payments')
      .insert({
        reservation_id: reservationId,
        payment_method: 'toss_payments',
        payment_status: 'deposit_paid',
        amount: depositAmount,
        is_deposit: true
      });
    
    // 잔금은 나중에 결제
    const remainingAmount = totalAmount - depositAmount;
    
    return {
      deposit_payment: depositPayment.data,
      remaining_amount: remainingAmount
    };
  }
}
```

---

## 🚀 배포 및 운영

### **환경 설정**
```typescript
// config/database.ts
export const dbConfig = {
  development: {
    url: process.env.SUPABASE_URL_DEV,
    key: process.env.SUPABASE_ANON_KEY_DEV
  },
  production: {
    url: process.env.SUPABASE_URL_PROD,
    key: process.env.SUPABASE_ANON_KEY_PROD
  }
};
```

### **실시간 업데이트 (WebSocket)**
```typescript
// services/websocket.service.ts
import { Server } from 'socket.io';

class WebSocketService {
  private io: Server;
  
  constructor(server: any) {
    this.io = new Server(server, {
      cors: {
        origin: process.env.FRONTEND_URL,
        methods: ["GET", "POST"]
      }
    });
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      // 관리자 인증
      socket.on('admin_auth', async (token) => {
        try {
          const admin = await this.verifyAdminToken(token);
          socket.join(`admin_${admin.id}`);
          socket.emit('auth_success', { adminId: admin.id });
        } catch (error) {
          socket.emit('auth_error', { message: '인증 실패' });
        }
      });
      
      // 샵 오너 인증
      socket.on('shop_owner_auth', async (token) => {
        try {
          const shopOwner = await this.verifyShopOwnerToken(token);
          socket.join(`shop_${shopOwner.shop_id}`);
          socket.emit('auth_success', { shopId: shopOwner.shop_id });
        } catch (error) {
          socket.emit('auth_error', { message: '인증 실패' });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('Client disconnected');
      });
    });
  }
  
  // 실시간 알림 발송
  public sendAdminNotification(adminId: string, notification: any) {
    this.io.to(`admin_${adminId}`).emit('notification', notification);
  }
  
  // 샵 예약 업데이트 알림
  public sendShopReservationUpdate(shopId: string, reservation: any) {
    this.io.to(`shop_${shopId}`).emit('reservation_update', reservation);
  }
  
  // 긴급 알림 (모든 관리자)
  public sendUrgentNotification(notification: any) {
    this.io.to('admin_*').emit('urgent_notification', notification);
  }
}
```

### **보안 강화 및 모니터링 (v3.2 업데이트)**

#### **API 보안 미들웨어**
```typescript
// middleware/security.middleware.ts
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { body, query, param } from 'express-validator';

// 강화된 Rate Limiting
export const createRateLimit = (config: RateLimitConfig) => {
  return rateLimit({
    windowMs: config.windowMs,
    max: config.max,
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        message: config.message,
        timestamp: new Date().toISOString()
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
  });
};

// SQL Injection 방지
export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
  const suspiciousPatterns = [
    /(\bUNION\b|\bSELECT\b|\bINSERT\b|\bUPDATE\b|\bDELETE\b|\bDROP\b)/i,
    /['"`;\\]/,
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi
  ];
  
  const checkValue = (value: any): boolean => {
    if (typeof value === 'string') {
      return suspiciousPatterns.some(pattern => pattern.test(value));
    }
    if (typeof value === 'object' && value !== null) {
      return Object.values(value).some(checkValue);
    }
    return false;
  };
  
  if (checkValue(req.body) || checkValue(req.query) || checkValue(req.params)) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'INVALID_INPUT',
        message: '부적절한 입력이 감지되었습니다',
        timestamp: new Date().toISOString()
      }
    });
  }
  
  next();
};

// CSRF 보호
export const csrfProtection = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers['x-csrf-token'] as string;
  const sessionToken = req.headers['authorization'] as string;
  
  if (!token || !sessionToken) {
    return res.status(403).json({
      success: false,
      error: {
        code: 'CSRF_TOKEN_MISSING',
        message: 'CSRF 토큰이 필요합니다',
        timestamp: new Date().toISOString()
      }
    });
  }
  
  // CSRF 토큰 검증 로직
  next();
};
```

#### **실시간 모니터링 시스템**
```typescript
// services/monitoring.service.ts
class MonitoringService {
  private metrics = new Map();
  
  // API 성능 메트릭 수집
  collectApiMetrics(req: Request, res: Response, responseTime: number) {
    const key = `${req.method}:${req.route?.path || req.path}`;
    const existing = this.metrics.get(key) || { count: 0, totalTime: 0, errors: 0 };
    
    existing.count++;
    existing.totalTime += responseTime;
    if (res.statusCode >= 400) existing.errors++;
    
    this.metrics.set(key, existing);
  }
  
  // 시스템 리소스 모니터링
  getSystemMetrics() {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    return {
      memory: {
        used: Math.round(memUsage.heapUsed / 1024 / 1024), // MB
        total: Math.round(memUsage.heapTotal / 1024 / 1024), // MB
        external: Math.round(memUsage.external / 1024 / 1024) // MB
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      },
      uptime: process.uptime()
    };
  }
  
  // 알림 임계값 모니터링
  async checkAlertThresholds() {
    const metrics = this.getSystemMetrics();
    
    // 메모리 사용량 80% 초과 시 알림
    if (metrics.memory.used / metrics.memory.total > 0.8) {
      await this.sendAlert('HIGH_MEMORY_USAGE', {
        current: metrics.memory.used,
        threshold: Math.round(metrics.memory.total * 0.8)
      });
    }
    
    // 에러율 5% 초과 시 알림
    const errorRate = this.calculateErrorRate();
    if (errorRate > 0.05) {
      await this.sendAlert('HIGH_ERROR_RATE', {
        current: Math.round(errorRate * 100),
        threshold: 5
      });
    }
  }
  
  private async sendAlert(type: string, data: any) {
    // Slack, 이메일, SMS 등으로 알림 발송
    console.error(`ALERT [${type}]:`, data);
  }
}
```

### **캐싱 전략**
```typescript
// services/cache.service.ts
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  // 샵 정보 캐싱 (1시간)
  async cacheShopInfo(shopId: string, shopData: any) {
    await this.redis.setex(`shop:${shopId}`, 3600, JSON.stringify(shopData));
  }
  
  // 사용자 포인트 캐싱 (5분)
  async cacheUserPoints(userId: string, pointsData: any) {
    await this.redis.setex(`points:${userId}`, 300, JSON.stringify(pointsData));
  }
  
  // 예약 현황 캐싱 (1분)
  async cacheReservationStatus(shopId: string, date: string, status: any) {
    await this.redis.setex(`reservations:${shopId}:${date}`, 60, JSON.stringify(status));
  }
  
  // 캐시 무효화
  async invalidateCache(pattern: string) {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

### **성능 모니터링**
- **APM 도구**: New Relic 또는 DataDog 연동
- **헬스체크**: `/health` 엔드포인트로 서버 상태 확인
- **메트릭 수집**: Prometheus + Grafana 대시보드
- **실시간 모니터링**: WebSocket 연결 수, API 응답 시간, 에러율

### **권한 매트릭스 (Permission Matrix)**
```typescript
// types/permissions.ts
export const PERMISSIONS = {
  // 사용자 관리
  USERS_READ: 'users:read',
  USERS_WRITE: 'users:write',
  USERS_DELETE: 'users:delete',
  USERS_SUSPEND: 'users:suspend',
  
  // 샵 관리
  SHOPS_READ: 'shops:read',
  SHOPS_WRITE: 'shops:write',
  SHOPS_DELETE: 'shops:delete',
  SHOPS_VERIFY: 'shops:verify',
  
  // 예약 관리
  RESERVATIONS_READ: 'reservations:read',
  RESERVATIONS_WRITE: 'reservations:write',
  RESERVATIONS_CANCEL: 'reservations:cancel',
  
  // 결제 관리
  PAYMENTS_READ: 'payments:read',
  PAYMENTS_REFUND: 'payments:refund',
  PAYMENTS_PARTIAL_REFUND: 'payments:partial_refund',
  
  // 포인트 관리
  POINTS_READ: 'points:read',
  POINTS_ADJUST: 'points:adjust',
  
  // 콘텐츠 관리
  CONTENT_READ: 'content:read',
  CONTENT_WRITE: 'content:write',
  CONTENT_DELETE: 'content:delete',
  
  // 시스템 설정
  SYSTEM_READ: 'system:read',
  SYSTEM_WRITE: 'system:write',
  SYSTEM_ADMIN: 'system:admin'
};

// 역할별 권한 정의
export const ROLE_PERMISSIONS = {
  // Super Admin: 모든 권한
  super_admin: Object.values(PERMISSIONS),
  
  // Shop Admin: 자신의 샵 관련 권한만
  shop_admin: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.RESERVATIONS_WRITE,
    PERMISSIONS.RESERVATIONS_CANCEL,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.CONTENT_READ
  ],
  
  // 일반 사용자: 읽기 권한만
  user: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.POINTS_READ,
    PERMISSIONS.CONTENT_READ
  ]
};

// 권한 검증 미들웨어
export const checkPermission = (requiredPermission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.user_role;
    const userPermissions = ROLE_PERMISSIONS[userRole] || [];
    
    if (!userPermissions.includes(requiredPermission)) {
      return res.status(403).json({
        success: false,
        error: {
          code: ERROR_CODES.INSUFFICIENT_PERMISSIONS,
          message: "해당 작업에 대한 권한이 없습니다",
          timestamp: new Date().toISOString(),
          requestId: req.headers['x-request-id'] as string
        }
      });
    }
    
    next();
  };
};
```

### **테스팅 전략 (Testing Strategy)**
```typescript
// tests/integration/api.test.ts
describe('API Integration Tests', () => {
  // 인증 테스트
  describe('Authentication', () => {
    test('should authenticate valid user', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'valid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.jwt_token).toBeDefined();
    });
    
    test('should reject invalid token', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'invalid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe('AUTH_1003');
    });
  });
  
  // 예약 시스템 테스트
  describe('Reservation System', () => {
    test('should prevent concurrent bookings', async () => {
      // 동시 예약 시도 테스트
      const promises = Array(3).fill(null).map(() =>
        request(app)
          .post('/api/reservations')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            shop_id: 'test_shop_id',
            reservation_date: '2024-03-20',
            reservation_time: '14:00',
            services: [{ service_id: 'test_service', quantity: 1 }]
          })
      );
      
      const results = await Promise.all(promises);
      const successful = results.filter(r => r.status === 200);
      
      expect(successful.length).toBe(1); // 하나만 성공해야 함
    });
  });
  
  // 포인트 시스템 테스트
  describe('Point System', () => {
    test('should apply influencer bonus correctly', async () => {
      const response = await request(app)
        .post('/api/points/earn')
        .set('Authorization', `Bearer ${influencerToken}`)
        .send({
          reservation_id: 'test_reservation',
          amount: 1000
        });
      
      expect(response.body.points_earned).toBe(2000); // 2배 보너스
    });
  });
});

// E2E 테스트
describe('End-to-End Tests', () => {
  test('complete reservation flow', async () => {
    // 1. 사용자 로그인
    const loginResponse = await request(app)
      .post('/api/auth/social-login')
      .send(loginData);
    
    const token = loginResponse.body.jwt_token;
    
    // 2. 샵 검색
    const searchResponse = await request(app)
      .get('/api/shops/nearby')
      .set('Authorization', `Bearer ${token}`)
      .query({ latitude: 37.5665, longitude: 126.9780 });
    
    const shopId = searchResponse.body.shops[0].id;
    
    // 3. 예약 생성
    const reservationResponse = await request(app)
      .post('/api/reservations')
      .set('Authorization', `Bearer ${token}`)
      .send({
        shop_id: shopId,
        reservation_date: '2024-03-20',
        reservation_time: '14:00',
        services: [{ service_id: 'test_service', quantity: 1 }]
      });
    
    expect(reservationResponse.status).toBe(200);
    
    // 4. 결제 처리
    const paymentResponse = await request(app)
      .post('/api/payments/toss/prepare')
      .set('Authorization', `Bearer ${token}`)
      .send({
        reservation_id: reservationResponse.body.reservation.id,
        amount: 45000
      });
    
    expect(paymentResponse.status).toBe(200);
  });
});
```

### **모니터링 및 알림 설정 (Monitoring Setup)**
```typescript
// monitoring/health-check.ts
export const healthCheck = {
  // 데이터베이스 연결 상태
  database: async () => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('count')
        .limit(1);
      
      return {
        status: error ? 'error' : 'healthy',
        response_time: Date.now(),
        error: error?.message
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // 외부 API 상태 (토스페이먼츠)
  external_apis: async () => {
    try {
      const response = await fetch('https://api.tosspayments.com/v1/health');
      return {
        status: response.ok ? 'healthy' : 'error',
        response_time: Date.now(),
        error: response.ok ? null : 'TossPayments API unavailable'
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // 메모리 및 CPU 사용량
  system_resources: () => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    return {
      memory: {
        rss: memUsage.rss,
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        external: memUsage.external
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      }
    };
  }
};

// 알림 설정
export const alerting = {
  // 에러율 알림
  errorRate: {
    threshold: 0.05, // 5% 이상 에러율
    window: 300000, // 5분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL
    }
  },
  
  // 응답 시간 알림
  responseTime: {
    threshold: 2000, // 2초 이상
    window: 60000, // 1분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL
    }
  },
  
  // 데이터베이스 연결 실패
  databaseConnection: {
    threshold: 3, // 3회 연속 실패
    window: 60000, // 1분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL,
      sms: process.env.ALERT_SMS
    }
  }
};

// 메트릭 수집
export const metrics = {
  // API 호출 수
  apiCalls: new Map(),
  
  // 응답 시간
  responseTimes: new Map(),
  
  // 에러 수
  errorCount: new Map(),
  
  // 활성 사용자 수
  activeUsers: new Set(),
  
  // 실시간 예약 수
  activeReservations: 0
};
```

### **보안 강화**
- **HTTPS 강제**: SSL 인증서 적용
- **API 키 관리**: AWS Secrets Manager 또는 환경변수
- **데이터베이스 보안**: RLS 정책 + VPC 네트워크 격리

---

이 설계서는 에뷰리띵 React/Next.js 하이브리드 앱과 웹 관리자 시스템을 지원하는 Node.js 백엔드의 모든 API 엔드포인트, 비즈니스 로직, 데이터베이스 상호작용을 상세히 설명합니다. 

**v3.2 주요 업데이트 사항:**
- ✅ 소셜 피드 시스템 완전 구현 (게시물, 좋아요, 댓글, 해시태그)
- ✅ 샵 다이렉트 메시지 기능 (카카오톡 채널 연동)
- ✅ 고도화된 포인트 시스템 (인플루언서 2배 보너스, 자동 만료 처리)
- ✅ 스마트 예약 시스템 ('요청' → '확정' 플로우)
- ✅ 지능형 환불 시스템 (24시간 규칙, 자동 처리)
- ✅ 콘텐츠 자동 모더레이션 (신고 기반 숨김 처리)
- ✅ 성능 최적화 (복합 인덱스, 캐싱 전략)
- ✅ 보안 강화 (Rate Limiting, 입력 검증, 이미지 보안)
- ✅ 표준화된 API 응답 형식

개발팀과의 기술 논의 및 구현 가이드로 활용할 수 있도록 구성되었습니다. 